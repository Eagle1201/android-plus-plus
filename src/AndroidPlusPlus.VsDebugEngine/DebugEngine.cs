////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Threading;
using System.IO;
using Microsoft.VisualStudio.Debugger.Interop;
using AndroidPlusPlus.Common;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  [ComVisible (true)]

  [Guid (DebugEngineGuids.guidDebugEngineStringCLSID)]

  [ClassInterface (ClassInterfaceType.None)]

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public class DebugEngine : IDebugEngine3, IDebugEngineLaunch2, IDebugEngineProgram2, IDebugSymbolSettings100
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private DebugEngineCallback m_sdmCallback;

    private AutoResetEvent m_broadcastHandleLock;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebugEngine ()
    {
      m_sdmCallback = null;

      BreakpointManager = new DebugBreakpointManager (this);

      m_broadcastHandleLock = new AutoResetEvent (false);

      LaunchConfiguration = new LaunchConfiguration ();

      Program = null;

      NativeDebugger = null;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public LaunchConfiguration LaunchConfiguration { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebuggeeProgram Program { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public CLangDebugger NativeDebugger { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public JavaLangDebugger JavaDebugger { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebugBreakpointManager BreakpointManager { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Broadcast (IDebugEvent2 debugEvent, IDebugProgram3 program, IDebugThread3 thread)
    {
      Broadcast (debugEvent, program as IDebugProgram2, thread as IDebugThread2);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Broadcast (IDebugEvent2 debugEvent, IDebugProgram2 program, IDebugThread2 thread)
    {
      Broadcast (m_sdmCallback, debugEvent, program, thread);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    public void Broadcast (IDebugEventCallback2 callback, IDebugEvent2 debugEvent, IDebugProgram2 program, IDebugThread2 thread)
    {
      LoggingUtils.PrintFunction ();

      try
      {
        if (callback == null)
        {
          throw new ArgumentNullException ("callback");
        }

        Guid eventGuid = ComUtils.GuidOf (debugEvent);

        uint eventAttributes;

        IDebugProcess2 programProcess;

        LoggingUtils.RequireOk (debugEvent.GetAttributes (out eventAttributes));

        LoggingUtils.RequireOk (program.GetProcess (out programProcess));

        if (((eventAttributes & (uint) enum_EVENTATTRIBUTES.EVENT_STOPPING) != 0) && (thread == null))
        {
          // For stopping events, this parameter cannot be a null value as the stack frame is obtained from this parameter.
          throw new ArgumentNullException ("thread");
        }

        LoggingUtils.RequireOk (callback.Event (this, null, program, thread, debugEvent, ref eventGuid, eventAttributes));

        if ((eventAttributes & (uint) enum_EVENTATTRIBUTES.EVENT_SYNCHRONOUS) != 0)
        {
          while (m_broadcastHandleLock.WaitOne (0))
          {
            Thread.Yield ();
          }
        }
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugEngine3 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Attach (IDebugProgram2 [] rgpPrograms, IDebugProgramNode2 [] rgpProgramNodes, uint celtPrograms, IDebugEventCallback2 ad7Callback, enum_ATTACH_REASON dwReason)
    {
      // 
      // Attach the debug engine to a program.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        m_sdmCallback = new DebugEngineCallback (this, ad7Callback);

        if ((rgpPrograms == null) || (rgpPrograms.Length == 0))
        {
          throw new ApplicationException ("Attach failed. No target process specified.");
        }

        if (celtPrograms > 1)
        {
          throw new ApplicationException ("Attach failed. Can't debug multiple target processes.");
        }

        if (Program != null)
        {
          throw new ApplicationException ("Attach failed. Already attached to " + Program.ToString ());
        }

        AndroidAdb.Refresh ();

        Program = rgpPrograms [0] as DebuggeeProgram;

        Program.AttachedEngine = this;

        NativeDebugger = new CLangDebugger (this, Program);

        LoggingUtils.RequireOk (Program.Attach (m_sdmCallback));

        NativeDebugger.NativeProgram.RefreshThreads ();

        CLangDebuggeeThread currentThread = NativeDebugger.NativeProgram.GetThread (NativeDebugger.NativeProgram.CurrentThreadId);

        if (currentThread == null)
        {
          // Lack of current thread is usually a good indication that connection/attaching failed.
          throw new InvalidOperationException ("Failed to retrieve program's current thread.");
        }

        JavaDebugger = new JavaLangDebugger (this, Program);

        // 
        // When this method is called, the DE needs to send these events in sequence:
        // 1. IDebugEngineCreate2
        // 2. IDebugProgramCreateEvent2
        // 3. IDebugLoadCompleteEvent2
        // 4. (if enum_ATTACH_REASON.ATTACH_REASON_LAUNCH), IDebugEntryPointEvent2
        // 

        Broadcast (new DebugEngineEvent.EngineCreate (this), Program, null);

        Broadcast (new DebugEngineEvent.ProgramCreate (), Program, null);

        Broadcast (new DebugEngineEvent.LoadComplete (), Program, currentThread);

        if (dwReason == enum_ATTACH_REASON.ATTACH_REASON_LAUNCH)
        {
          Broadcast (new DebugEngineEvent.EntryPoint (), Program, currentThread);
        }

        //Broadcast (new DebugEngineEvent.AttachComplete (), Program, null);

        return DebugEngineConstants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        Broadcast (new DebugEngineEvent.Error (e.Message, true), Program, null);

        return DebugEngineConstants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int CauseBreak ()
    {
      // 
      // Requests all programs being debugged by this DebugEngine instance stop execution (next time one of their threads attempts to run).
      // Normally called in response to user clicking the PAUSE button in the debugger.
      // When the break is complete, an AsyncBreakComplete event will be sent back to the debugger.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        LoggingUtils.RequireOk (Program.DebugProcess.CauseBreak ());

        return DebugEngineConstants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int ContinueFromSynchronousEvent (IDebugEvent2 eventObject)
    {
      // 
      // Called by the Session Debug Manager (SDM) to indicate that a synchronous event, previously sent by the DebugEngine to the SDM,
      // was received and processed. An example of this is 'Program Destroy', which triggers a shutdown of the DebugEngine.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        m_broadcastHandleLock.Set ();

        return DebugEngineConstants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int CreatePendingBreakpoint (IDebugBreakpointRequest2 pBPRequest, out IDebugPendingBreakpoint2 ppPendingBP)
    {
      // 
      // Creates a pending breakpoint for this DebugEngine. 
      // A 'PendingBreakpoint' contains all required data to bind a breakpoint to a location in the debuggee.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        LoggingUtils.RequireOk (BreakpointManager.CreatePendingBreakpoint (pBPRequest, out ppPendingBP));

        return DebugEngineConstants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        ppPendingBP = null;

        return DebugEngineConstants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int DestroyProgram (IDebugProgram2 pProgram)
    {
      // 
      // Informs a DebugEngine that the program specified has been atypically terminated, and that the DebugEngine should
      // clean up all references to the program and send a 'program destroy' event.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int EnumPrograms (out IEnumDebugPrograms2 programs)
    {
      // 
      // Retrieves a list of all programs being debugged by a debug engine (DE).
      // 

      LoggingUtils.PrintFunction ();

      programs = new DebuggeeProgram.Enumerator (new List<IDebugProgram2> { Program });

      return DebugEngineConstants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetEngineId (out Guid guidEngine)
    {
      // 
      // Gets the GUID of the DebugEngine.
      // 

      LoggingUtils.PrintFunction ();

      guidEngine = DebugEngineGuids.guidDebugEngineID;

      return DebugEngineConstants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int LoadSymbols ()
    {
      // 
      // Loads (as necessary) symbols for all modules being debugged by this debugging engine.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int RemoveAllSetExceptions (ref Guid guidType)
    {
      // 
      // Removes the list of exceptions the IDE has set for a particular run-time architecture or language.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int RemoveSetException (EXCEPTION_INFO [] pException)
    {
      // 
      // Removes the specified exception so it is no longer handled by the DebugEngine.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetAllExceptions (enum_EXCEPTION_STATE dwState)
    {
      // 
      // This method sets the state of all outstanding exceptions.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetException (EXCEPTION_INFO [] pException)
    {
      // 
      // Specifies how the DebugEngine should handle a given exception.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetEngineGuid (ref Guid guidEngine)
    {
      // 
      // This method sets the debug engine's (DE) GUID.
      // 

      LoggingUtils.PrintFunction ();

      return DebugEngineConstants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetJustMyCodeState (int fUpdate, uint dwModules, JMC_CODE_SPEC [] rgJMCSpec)
    {
      // 
      // This method tells the debug engine about the JustMyCode state information.
      // 

      LoggingUtils.PrintFunction ();

      return DebugEngineConstants.E_NOTIMPL;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetLocale (ushort wLangID)
    {
      // 
      // Called by the Session Debug Manager (SDM) to propagate the locale settings of the IDE.
      // 

      LoggingUtils.PrintFunction ();

      return DebugEngineConstants.S_OK; // Not localised.
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetMetric (string pszMetric, object varValue)
    {
      // 
      // A metric is a registry value used to change Engine behaviour or advertise supported functionality.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetRegistryRoot (string pszRegistryRoot)
    {
      // 
      // Sets the registry root for the Engine. Different VS installations can change where their registry data is stored.
      // 

      LoggingUtils.PrintFunction ();

      return DebugEngineConstants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetSymbolPath (string szSymbolSearchPath, string szSymbolCachePath, uint Flags)
    {
      // 
      // Sets the path or paths that are searched for debugging symbols.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugEngineLaunch2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int CanTerminateProcess (IDebugProcess2 process)
    {
      // 
      // Determines if a process can be terminated.
      // 

      LoggingUtils.PrintFunction ();

      return DebugEngineConstants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int LaunchSuspended (string pszServer, IDebugPort2 port, string exe, string args, string dir, string env, string options, enum_LAUNCH_FLAGS launchFlags, uint hStdInput, uint hStdOutput, uint hStdError, IDebugEventCallback2 ad7Callback, out IDebugProcess2 process)
    {
      // 
      // Normally, VS launches a program using the IDebugPortEx2::LaunchSuspended method, and the attaches the debugger to the suspended program.
      // However, there are circumstances in which the DebugEngine may need to launch a program or other dependencies (e.g. tools or interpreters) in which case this method is used.
      // IDebugEngineLaunch2::ResumeProcess method is called to start the process after the program has been launched in a suspended state.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        if (port == null)
        {
          throw new ArgumentNullException ("port");
        }

        // 
        // Evaluate options; including current debugger target application.
        // 

        if (LaunchConfiguration == null)
        {
          throw new InvalidOperationException ("No launch configuration found.");
        }

        LaunchConfiguration.FromString (options);

        string packageName = LaunchConfiguration ["PackageName"];

        string launchActivity = LaunchConfiguration ["LaunchActivity"];

        bool debugMode = LaunchConfiguration ["DebugMode"].Equals ("true");

        bool keepData = LaunchConfiguration ["KeepAppData"].Equals ("true");

        bool openGlTrace = LaunchConfiguration ["OpenGlTrace"].Equals ("true");

        // 
        // Check for an installed application matching the package name, install provided APK if not found.
        // 

        DebuggeePort debuggeePort = port as DebuggeePort;

        bool appIsInstalled = debuggeePort.PortDevice.Shell ("pm", "path " + packageName, 5000).Contains ("package:");

        bool appIsRunning = false;

#if FALSE
        if (!appIsInstalled)
#endif
        {
          //debuggeePort.PortDevice.Uninstall (packageName, keepData);

          if (!File.Exists (exe))
          {
            throw new FileNotFoundException ("Failed to find target application: " + exe);
          }

          if (!debuggeePort.PortDevice.Install (exe, keepData))
          {
            throw new InvalidOperationException ("Failed to install target application: " + exe);
          }

          appIsInstalled = true;
        }

        // 
        // Launch application on device in a 'suspended' state.
        // 

        try
        {
          if (!appIsRunning)
          {
            StringBuilder launchArgumentsBuilder = new StringBuilder ();

            launchArgumentsBuilder.Append ("start ");

            if (debugMode)
            {
              launchArgumentsBuilder.Append ("-D "); // debug
            }
            /*else
            {
              launchArgumentsBuilder.Append ("-W "); // wait
            }*/

            launchArgumentsBuilder.Append (packageName + "/" + launchActivity);

            string launchResponse = debuggeePort.PortDevice.Shell ("am", launchArgumentsBuilder.ToString (), 5000);

            if (string.IsNullOrEmpty (launchResponse) || launchResponse.Contains ("Error:"))
            {
              throw new InvalidOperationException ("Launch intent failed. Response: " + launchResponse);
            }
          }
        }
        catch (Exception e)
        {
          LoggingUtils.HandleException (e);

          throw e;
        }

        // 
        // Query whether the target application is already running. (Double-check)
        // 

        DebuggeeProcess debugProcess = null;

        while (!appIsRunning)
        {
          IEnumDebugProcesses2 portProcesses;

          uint deviceProcessCount = 0;

          LoggingUtils.RequireOk (debuggeePort.EnumProcesses (out portProcesses));

          LoggingUtils.RequireOk (portProcesses.GetCount (out deviceProcessCount));

          DebuggeeProcess [] deviceProcesses = new DebuggeeProcess [deviceProcessCount];

          LoggingUtils.RequireOk (portProcesses.Next (deviceProcessCount, deviceProcesses, ref deviceProcessCount));

          // 
          // Our new process is likely to be toward the end, so reverse the process lookup.
          // 

          for (uint i = (deviceProcessCount - 1); i > 0; --i)
          {
            string processName;

            LoggingUtils.RequireOk (deviceProcesses [i].GetName (enum_GETNAME_TYPE.GN_NAME, out processName));

            if (packageName.Equals (processName, StringComparison.OrdinalIgnoreCase))
            {
              debugProcess = deviceProcesses [i];

              appIsRunning = true;

              break;
            }
          }

          if (!appIsRunning)
          {
            Thread.Yield ();
          }
        }

        // 
        // Attach to launched process.
        // 

        if (debugProcess == null)
        {
          throw new InvalidOperationException ("Process failed to launch. Could not continue.");
        }

        process = debugProcess;

        m_sdmCallback = new DebugEngineCallback (this, ad7Callback);

        return DebugEngineConstants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        process = null;

        return DebugEngineConstants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int ResumeProcess (IDebugProcess2 process)
    {
      // 
      // Resume a process launched by IDebugEngineLaunch2.LaunchSuspended
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        // 
        // Send a program node to the SDM. 
        // This will cause the SDM to turn around and call IDebugEngine2.Attach which will complete the hookup with AD7
        // 

        IDebugPort2 port;

        DebuggeeProcess debugProcess = process as DebuggeeProcess;

        LoggingUtils.RequireOk (debugProcess.GetPort (out port));

        DebuggeePort debugPort = port as DebuggeePort;

        LoggingUtils.RequireOk (debugPort.AddProgramNode (debugProcess.DebuggeeProgram));

        return DebugEngineConstants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);
      }

      return DebugEngineConstants.E_FAIL;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int TerminateProcess (IDebugProcess2 process)
    {
      // 
      // Terminate a process launched by IDebugEngineLaunch2.LaunchSuspended.
      // The debugger will call IDebugEngineLaunch2.CanTerminateProcess before calling this method.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        // 
        // Termination controlled via IDebugProgram3.Terminate (), which has already been called on the native program object.
        // 

        if (process == null)
        {
          throw new InvalidOperationException ();
        }

        DebuggeeProcess debugProcess = (process as DebuggeeProcess);

        Broadcast (new DebugEngineEvent.ProgramDestroy (0), debugProcess.DebuggeeProgram, null);

        debugProcess.Terminate ();
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);
      }
      finally
      {
        if (NativeDebugger != null)
        {
          NativeDebugger.Dispose ();

          NativeDebugger = null;
        }

        if (JavaDebugger != null)
        {
          JavaDebugger.Dispose ();

          JavaDebugger = null;
        }
      }

      return DebugEngineConstants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugEngineProgram2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Stop ()
    {
      // 
      // Stops all threads running in this program.
      // This method is called when this program is being debugged in a multi-program environment. 
      // This DebugEngine only supports debugging native applications and therefore only has one program per-process.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int WatchForExpressionEvaluationOnThread (IDebugProgram2 pOriginatingProgram, uint dwTid, uint dwEvalFlags, IDebugEventCallback2 pExprCallback, int fWatch)
    {
      // 
      // WatchForExpressionEvaluationOnThread is used to cooperate between two different engines debugging the same process.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int WatchForThreadStep (IDebugProgram2 pOriginatingProgram, uint dwTid, int fWatch, uint dwFrame)
    {
      // 
      // WatchForThreadStep is used to cooperate between two different engines debugging the same process.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugSymbolSettings100 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int SetSymbolLoadState (int bIsManual, int bLoadAdjacent, string strIncludeList, string strExcludeList)
    {
      // 
      // The SDM will call this method on the debug engine when it is created, to notify it of the user's
      // symbol settings in Tools->Options->Debugging->Symbols.
      //
      // Params:
      // 
      // bIsManual        true if 'Automatically load symbols: Only for specified modules' is checked
      // bLoadAdjacent    true if 'Specify modules'->'Always load symbols next to the modules' is checked
      // strIncludeList   semicolon-delimited list of modules when automatically loading 'Only specified modules'
      // strExcludeList   semicolon-delimited list of modules when automatically loading 'All modules, unless excluded'
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return DebugEngineConstants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
