////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Threading;

using Microsoft.Build.Framework;
using Microsoft.Win32;
using Microsoft.Build.Utilities;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.MsBuild.Common
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public class TrackedFileManager
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private Dictionary<string, List<string>> m_dependencyTable;

    private Encoding m_defaultEncoding = Encoding.Unicode;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public TrackedFileManager ()
    {
      m_dependencyTable = new Dictionary<string, List<string>> ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void ImportFromExistingTLog (ITaskItem tlog)
    {
      // 
      // Parse and collate a TLog. It's best to achieve this by associating dependancy graph 'entries' with associated sources.
      // 
      // Format:
      // 
      //    ^FILE1.C
      //    FILE1.OBJ
      //    ^FILE2.C|FILE3.C
      //    FILE2.OBJ
      //    FILE3.OBJ
      // 

      if (tlog == null)
      {
        throw new ArgumentNullException ();
      }

      string tlogFullPath = (!string.IsNullOrEmpty (tlog.GetMetadata ("FullPath")) ? tlog.GetMetadata ("FullPath") : Path.GetFullPath (tlog.ItemSpec));

      if (string.IsNullOrEmpty (tlogFullPath))
      {
        throw new ArgumentException ("Could not get 'FullPath' metadata for TLog. " + tlog);
      }

      if (File.Exists (tlogFullPath))
      {
        try
        {
          using (StreamReader reader = new StreamReader (tlogFullPath, m_defaultEncoding))
          {
            if (reader != null)
            {
              string trackedSourceLineData = reader.ReadLine ();

              while (!string.IsNullOrWhiteSpace (trackedSourceLineData))
              {
                if (trackedSourceLineData.StartsWith ("^"))
                {
                  List<string> trackedSources = new List<string> (trackedSourceLineData.Substring (1).ToUpperInvariant ().Split ('|'));

                  string trackedDependencyEntriesLineData = reader.ReadLine ();

                  while (!string.IsNullOrWhiteSpace (trackedDependencyEntriesLineData))
                  {
                    List<string> dependentSources;

                    if (m_dependencyTable.TryGetValue (ConvertToTrackerFormat (trackedDependencyEntriesLineData), out dependentSources))
                    {
                      foreach (string source in trackedSources)
                      {
                        if (!dependentSources.Contains (ConvertToTrackerFormat (source)))
                        {
                          dependentSources.Add (ConvertToTrackerFormat (source));
                        }
                      }
                    }
                    else
                    {
                      m_dependencyTable.Add (ConvertToTrackerFormat (trackedDependencyEntriesLineData), new List<string> (trackedSources));
                    }

                    trackedDependencyEntriesLineData = reader.ReadLine ();
                  }
                }

                trackedSourceLineData = reader.ReadLine ();
              }

              reader.Close ();
            }
          }
        }
        catch (Exception e)
        {
          throw e;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public ITaskItem [] ComputeSourcesNeedingCompilation ()
    {
      throw new NotImplementedException ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void AddDependencyForSources (string dependency, ITaskItem [] sources)
    {
      List<string> dependentSources;

      try
      {
        foreach (ITaskItem source in sources)
        {
          string sourceFullPath = source.GetMetadata ("FullPath");

          if (m_dependencyTable.TryGetValue (ConvertToTrackerFormat (dependency), out dependentSources))
          {
            if (!dependentSources.Contains (ConvertToTrackerFormat (sourceFullPath)))
            {
              dependentSources.Add (ConvertToTrackerFormat (sourceFullPath));
            }
          }
          else
          {
            m_dependencyTable.Add (ConvertToTrackerFormat (dependency), new List<string> (new string [] { ConvertToTrackerFormat (sourceFullPath) }));
          }
        }
      }
      catch (Exception e)
      {
        throw e;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void RemoveSourcesFromTable (ITaskItem [] sources)
    {
      // 
      // Iterate through the entire dependency table removing any of the specified sources. Remove empty entries.
      // 

      List<string> emptyEntries = new List<string> ();

      try
      {
        foreach (KeyValuePair<string, List<string>> tableEntry in m_dependencyTable)
        {
          foreach (ITaskItem source in sources)
          {
            tableEntry.Value.Remove (ConvertToTrackerFormat (source.GetMetadata ("FullPath")));
          }

          if ((tableEntry.Value.Count == 0) && (emptyEntries.Contains (tableEntry.Key)))
          {
            emptyEntries.Add (tableEntry.Key);
          }
        }

        foreach (string entry in emptyEntries)
        {
          m_dependencyTable.Remove (entry);
        }
      }
      catch (Exception e)
      {
        throw e;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void RemoveOutputsFromTable (ITaskItem [] outputs)
    {
      // 
      // Remove any entries for the specified output dependencies.
      // 

      try
      {
        foreach (ITaskItem output in outputs)
        {
          m_dependencyTable.Remove (ConvertToTrackerFormat (output.GetMetadata ("FullPath")));
        }
      }
      catch (Exception e)
      {
        throw e;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Save (ITaskItem tlog)
    {

      /*Dictionary<string, List<string>> condensedSourceBasedDependencyTable = new Dictionary<string, List<string>> ();

      foreach (KeyValuePair<string, List<string>> tableEntry in m_dependencyTable)
      {
        foreach (string source in tableEntry.Value)
        {
          List <string> dependentEntries;

          if (condensedSourceBasedDependencyTable.TryGetValue (source, out dependentEntries))
          {
            if (!dependentEntries.Contains (source))
            {
              dependentEntries.Add (source);
            }
          }
          else
          {

          }

        }
      }*/

      try
      {
        if (tlog == null)
        {
          throw new ArgumentNullException ();
        }

        string tlogFullPath = (!string.IsNullOrEmpty (tlog.GetMetadata ("FullPath")) ? tlog.GetMetadata ("FullPath") : Path.GetFullPath (tlog.ItemSpec));

        if (string.IsNullOrEmpty (tlogFullPath))
        {
          throw new ArgumentException ("Could not get 'FullPath' metadata for TLog. " + tlog);
        }

        using (StreamWriter writer = new StreamWriter (tlogFullPath, false, Encoding.Unicode))
        {
          StringBuilder sourceFileList = new StringBuilder ();

          foreach (KeyValuePair<string, List<string>> tableEntry in m_dependencyTable)
          {
            sourceFileList.Length = 0;

            foreach (string source in tableEntry.Value)
            {
              sourceFileList.Append ("|" + source.ToUpperInvariant ());
            }

            sourceFileList.Replace ('|', '^', 0, 1);

            writer.WriteLine (sourceFileList.ToString ());

            writer.WriteLine (tableEntry.Key);
          }

          writer.Close ();
        }
      }
      catch (Exception e)
      {
        throw e;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private static string ConvertToTrackerFormat (string original)
    {
      return original.ToUpperInvariant ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
